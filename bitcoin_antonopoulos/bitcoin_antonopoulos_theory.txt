WARNING: This file is TXT with my own personal formatting style,
in which ideas are indented according to their hierarchical relationships.
Mikel Sagardia, 2019-2020

Altogether, two major sources are summarized:
- "Mastering Bitcoin", A. Antonopoulos, O'Reilly
- "Bitcoin and Cryptocurrency Bootcamp", Udemy - Colt Steele, Kevin Katz

####################################
# Mastering Bitcoin (Antonopoulos Book): Notes
####################################

## Chapter 1: Introduction
	
	https://github.com/bitcoinbook/bitcoinbook
	
## Chapter 2: How Bitcoin Works

	bitcoin system consists of
		wallets containing keys
		transactions that are propagated across the network
		miners who produce (through competition) the consensus blockchain

	bitcoin explorers
		https://www.blockchain.com
		IMPORTANT NOTE: whenever you use an online service, your IP is logged with the info you check!
		use the explorer from your node!

		usage
			https://www.blockchain.com/btc/tx/<tx-id>
			https://www.blockchain.com/btc/tx/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2

	# Transactions 

		transactions: inputs + outputs
			inputs = outputs + fees
				inputs: debits
				outputs: credits
			bitcoin adresses transfer value (inputs) to new bitcoin adresses (outputs)
			a small fee is taken from the inputs,
				which goes to the node that writes the transaction into the blockchain
			several inputs and outputs (& adresses) can appear in a transaction
			spending = signing a transaction that trasnfers value to a new adress
			inputs contain proof of ownership, independently verifyable

		transaction chains
			the input values in a transaction know the transaction they come from
			previous outputs are divided in
				spent, the fractions that are used as inputs for successive transactions
				unspent, the fractions that are not used (by now) = UTXO
			wallet keys basically unlock the transaction outputs of previous transactions

		making change
			when value is transferred from an adress (input) to another (output)
			if the coins in the input adress dont match the transferred value + fees,
			change is generated and returned to the input wallet, but maybe to a new adress
				that's the change address

		common transaction forms
			1. Simple payment
				Input 0
					From Alice signed by Alice
				Output 0
					To Bob
				Output 1
					To Alice: Change
			2. Aggregated inputs: like gathering many coins
				Inputs 0 - N
					From Alice signed by Alice
				Output 0
					To Bob
			3. Distributed outputs: payroll of multiple employees
				Input 0
					From Alice signed by Alice
				Outputs 0 - N
					To several wallets/adresses

	# Constructing a transaction

		a wallet needs
			(0. the private key)
			1. destination (public) adress
			2. amount
		to construct the transaction - which can even happen offline!

		a wallet connected to a full node knows about all the unspent coins/output
			therefore, they can quickly veryfy any incoming transaction!

		outputs are created like scripts:
			anyone who can provide with proof/signature of having the destination wallet receives the coins

		the peer-to-peer bitcoin network propagates the transactions
			any node that receives and confirms a transaction immediately forwards it to the nodes connected to it

		COMMON MISCONCEPTION: that txs must be confirmed waiting 10 mins for a new block or 60 minutes (6 blocks)
			- confirmations ensure that tx has been accepted by whole network
			- but, if A pays to B in front of him/her and B receives the tx notification, there's no need to wait
			- confirmations are rather for the rest of the network or maybe for huge valuess

	# Bitcoin mining

		Transactions are propagated through the network and aggregated to blocks,
			which are included to the blockchain = this is through mining

		There is a pool of unverified transactions where all new tx land
			txs are prioritized, among others, according to the fees paid by the senders
			each mining node creates a block to be added by stacking
				1. next prioritized txs
				2. a reward tx for itself
					aggregated fees for prioritized txs + new bitcoin issued
				3. a fingerprint of the previous block
			and then start guessing a puzzle which is
				very difficult to guess
				but very easy to verify
				so, like a sudoku, it's asymmetrically hard to solve/verify

		So:
			- every 10 minutes, all nodes start competing
			- only the node which first guesses the game writes the block and receives the reward
			- when a node makes the guess, it notifies its peers, and they verify it and start competing for the next block

		The game / value to be guessed is called Proof-of-Work (PoW)
			the header of the block + random number are hashed to obtain a pattern
			the random number is the sought value!

		The difficulty of the game is adjusted depending on the nodes in the network so that the value can be guessed every 10 minutes (= a block created every 10 minutes)

		Nowadays
			- ASICs are used: HW in which mining algos were printed
			- Miners join in mining pools: many miners who share rewards

		Terms
			Block height: number of blocks since genesis block until block with observed trsnaction
			Block depth: number of blocks from observed block until very last added

		Some insights:
			- As blocks pile on each other, they become exponentially harder to falsify/reverse -> more trusted
				by CONVENTION, a block with 6+ confirmations is irrevocable, because it would require many energy to invalidate and recalculate the 6 blocks
			- Blocks can be written into the blockchain iff Proof-of-Work is shown
			- Writing a block means getting the reward
			- Therefore, we do not need a central authority: distributed nodes compete and respect the easy to verify rules

	# Spending the transaction

		Some key ideas
		- each bitcoin client can verify a tx as valid
		- full nodes can track the source of fund until the moment in which they were generated
		- SPV nodes (Simplified Payment Verification, or lightweight) can confirm that the tx is in the blockschain and has several blocks mined after it

## Chapter 3: Bitcoin Core: The Reference Implementation

	Bitcoin Core: Repository
		https://github.com/bitcoin/bitcoin
		MIT license
		originally published by Satoshi Nakamoto, now handled by many other developers
		original Bitcoin Core implementation has
			Wallet - but better use another one, more secure
			Transacton & block validation engine
			Full network node

	Bitcoin core compilation done step by step - I've done that already

	After compilation,
		we get 2 main executables
			/usr/local/bin/bitcoind
				the node running all the time
			/usr/local/bin/bitcoin-cli
				the client to connect to the node
		we need to set the configuration file ~.bitcoin/bitcoin.conf
			choose strong pw for RPC
			'bitcoind --help' displays all possible config params, like
				datadir: where the blockchain data will go
				prune: delete old blocks
				txindex: maintain index of transactions (set it to 1 if we want to check any tx)
				maxconnections
				...

	To start bitcoin node:
		bitcoind -daemon
		usually, it's set to the start-up files/script

	To get info from the node, use:
		bitcoin-cli [command]

	Bitcoin Core Application Programming Interface: bitcoin-cli

		bitcoin-cli is a JSON-RPC interface
			RPC = Remote Procedure Call
			that means: bitcoin-cli is the client which requests the server bitcoind (the node) for info,
			which is delivered as JSON strings

	bitcoin-cli commands

		bitcoin-cli help [command]
			eg, bitcoin-cli help getblockhash
		bitcoin-cli getinfo
			status of our node
		bitcoin-cli getrawtransaction <tx id>
			hexadecimal code of transaction is returned, we need to decode it
		bitcoin-cli decoderawtransaction <tx hexadecimal>
			JSON string of tx is returned
			we see the values and the adresses in it
		bitcoin-cli getblockhash 1000
			hash of block with index 1000, we need to decode it
			the index or id is called the height
		bitcoin-cli getblock <block hash>
			JSON string of block returned
			here, we can see all the transactions of the block
			we can follow the transactions...

	RPC interface
		we can access the node via HTTPS protocol
		for instance using curl or any other tool
		there is an example in the book for that
		anothe option is to use libraries that do that

	Libraries
	There are many lilbraries, eg for python: python-bitcoinlib
	https://github.com/petertodd/python-bitcoinlib

		3 examples shown
		- get number of blocks so far
		- get outputs of a tx
		- get all the outputs of all txs in a block

## Chapter 4: Keys, Addresses

	Bitcoin communication & data are not encrypted
	We have 3 main elements
		1. Digital or provate keys
			- they are not stored on the network, but in wallets
			- used to create identity signatures: we can spend sats linked to an address if we show the signature of the private key
			- used to create public keys
			- they can be generated and managed without access to the blockchain!
			- so, used to spend funds, it's like the PIN
		2. Public keys
			- created from the private key: easy to create and verify, but impossible to get original private key
			- it is used to receive funds 
		3. Adresses
			- hashed public keys
			- usually, the elements used to send/receive
			- behind an adress we can have a wallet or a script

	Public key cryptography (that's not in the book)

		https://www.youtube.com/watch?v=AQDCe585Lnc&vl=en

		We distinguish mainly two types of encryptions:
			1. Symmetric
				We create a key/password which is used to encrypt a content
				The same key is used to decrypt the content
				The issue with this framework: sometimes sharing the key through a channel can be unfeasible or dangerous
			2. Asymmetric 
				We create a key pair: the private and the public key
					the private is kept private, never ever shared
					the public is shared with all our peers
				If a peer wants to send me a content, he/she encrypts it with my public key
				When I receive it, I decrypt it with the linked private key
				So
					the public key is used by others to encrypt content sent to me
					the private is used by me to decrypt the content they send me

		Notes on the asymmetric encryption
		- The key private-public key pair is linked, but
			we derive the public key from the private one
			we cannot obtain the private key from the public
		- The private key is able to decrypt content encrypted only by its linked public key

		Aplications that use asymmetric encryption (my interpretation, not sure if it is 100% like that)
			HTTPS (SSL)
				a web owner pays an authority to keep a private key of my website
				when I visit the web, my browser gets the public key of the web and the address of the authority
				additionally, the web provides a message from the authority whichs needs to be encrypted with the public key
				the authority descrypts the message; if it's correct, the identity of the web is verified
			Bitcoin
				We verify the ownership of the funds by decrypting any message encrypted with our address/public key
			SSH
				similar to HTTPS to verify identities
			PGP or GPG
				Pretty Good Privacy
				Asymmetric encryption applied to emails / messages
				basically, we apply the explanation of the asymmetric encryption above

				It's possible to install it on Thunderbird
				or you can use the GPG Keychain application
				Alternatively, you can install the command line tool too, and do eveything manually
	
					https://blog.ghostinthemachines.com/2015/03/01/how-to-use-gpg-command-line/
	
					brew install gnupg
					sudo apt-get install gnupg

					gpg --gen-key
					...

	Private & public keys

		private key k -> (elliptic curve multiplication) -> Public key K -> (hashing) -> Bitcoin Adress A
		we can go only one way, not back

		main idea: the spend signature can be generated only with the private key but can be verified by the public key available to anyone

		the private key is basically a random number of 256 bits: 2^(256)
			usually it's encoded in
				hexadecimal: base 16 = base 4 bits = 2^4
				Base58: base 64 - 6 characters difficult to distinguish

		how to obtain the 
		bitcoin-cli getnewaddress
			private key is generated and address returned
			<address>
		bitcoin-cli dumpprivkey <address>
			if we input our generated address, wallet is opened and its private key is returned
			note: we dont obtain the priv key of an arbitrary address, but we open the wallet and return the priv key

		Public keys are create by elliptic curve multiplication
			elliptic curve multiplication is irreversible
			the elliptic curve is the curve y^2 = x^3 + 7 discretized
				it's symmetric on x
				it has (x,y) coordinates, each of which is a pissible private key of all 2^256

				the addition of points P1 & P2 of the curve is defined as follows
					a line is drew between P1 & P2 and where it intersects, we have P3'
					if we reflect its y value, we have P3

				multiplication is defined as a sum
					k*P = P + P + P + ..., k times
					adding a point P to itself is basically throwing the tangent line and reflecting the intersection point

			basically, the public key K is created by elliptic curve multiplication:

				K = G * k
					K: public key
					G: generator point, same and known to everyone
					k: private key

	Bitcoin addresses

		a bitcoin adress can be
			an owner of a private key
			a payment script

		the address is created double-hashing the public key with SHA256 and RIPEMD160

			A = RIPEMD160(SHA256(K))

		encoding

			Base58: Base64 - 6 symbols difficult to distinguish = 0-9, a-z, A-Z - (0, O, l, I)
			Base58Check: Base58 with additional checksum at the end; it has also a prefix to denote it's a Base58Check address
				prefix 1: bitcoin address
				prefix 3: payment address

	Key formats

		private key formats
			raw: 32 bytes
			hex: 64 hexadecimal digits
			WIF = wallet import format = Base58Check: prefix 5
			WIF-compressed = prefix K or L, suffix 0x01 (this hexadecimal suffix is converted to Base58Check)
				note: WIF-compressed are not really compressed, it means they should be used to derive compressed public keys

		public key formats

			public keys can be compressed/uncompressed
			recall a public key is a point (x,y) in the elliptic curve
				since the elliptic curve is symmetric in x, we just need x and the sign of y!

			uncompressed, the public key has the form
				04 x y
				04: prefix
				x: 256-bit x coordinate of the point on the elliptic curve
				y: 256-bit y coordinate

			compressed, we take only the x coordinate with prefix 02 (y positive) or 03 (y negative)
				02 x
				03 x

			notes
			- if we hash a compressed or uncompressed key, the result is different!
			- however, the private key is the same!
			- to enable compatibilities, the private keys have a suffix 0x01 when they need to be used to generate compressed public keys
				that's the WIF-compressed format = Base58Check + suffix 0x01 (hexadecimal)

	Encrypted provate keys (BIP-38)
		BIP = Bitcoin Improvement Proposal
		Basically, private keys are encrypted with a passphrase (password) - and we need that password to decrypt them again
		The result is a private key in Base58Check that begins with 6P
	
	Pay-to-Script Hash (P2SH) and Multisig Addresses
		Bitcoin addresses which begin with 3 designate as beneficiary a script
			the script then specifies the conditions to spend the funds
		Currently, th emost common implementation would be a  multisignature address script:
			the script requires M signatures of N>=M to prove ownership and spend funds

	Vanity addresses

		addresses that contain human-readable parts, eg
		1Love....

		they are basically generated by testing random private keys until the desired pattern appears

		a pattern of 4 symbols can be found in 1 min aprox
		a pattern of 10 requires 46000 years

	Paper Wallets

		very good for cold storage
		IMPORTANT
			we can deposit several times
			BUT we should withdaw only once!
			this is because sometimes change address are created

		sometmies the keys are encrypted and we need a passphrase to decrypt them

		bitaddress.org
			we can save the page and generated paper wallet
		bitcoinpaperwallet.com

	Code examples: C++ & Python

		p. 69: C++ example of generation of private key and an address from it
		p. 77: Python example of the same (pybitcointools by Vitalik Buterin)

## Chapter 5: Wallets

	Wallets are the primary user interface but their main goal is to safely keep private keys
		Wallets do not contain bitcoins
		Bitcoins are mere transaction outputs on the blockchain
		Wallets just contain the keys to spend them

	Two main types of wallets
	1. Non-deterministic wallets
		just random private keys created and stored
		not common anymore, discouraged
	2. (Hierarchical) Deterministic wallets (HD)
		they contain private keys that are derived from a seed, using one-ways hashing
		with the seed, all private keys can be generated (which are really many)

	HD Wallets (BIP-32, BIP-44) = Hierarchical Deterministic Wallets

		all private keys contained by the wallet derived from a seed in a tree structure
			each child of a parent node becomes a parent that can create children, and so on

		advantages
		- tree structure can be used to give meaning to subsets/branches, eg departments, etc
		- VERY IMPORTANT: it is possible to create the public keys of the tree without having the private keys

		Mnemonic codes are used to generate 512-bit seeds (BIP-39)

			mnemonic codes are easy-to remember words
			12-24 english words, each one from a dictionary of 2024 words
				2024 = 2^11 = 11 bits

			when we start/create a wallet with latest standard, it generates a RANDOM bit-string which is encoded in 12 words
			from these 12 words we can create an unending number of private and public keys

		From mnemonic codes to seed

			the mnemonic words + salt are stretched using a special cryptographic function up to a 512-bit seed
			the salt is the string "mnemonic" + optional pasphrase, which adds extra security
				for instance, we could write down the 12 words for back up, but not the passphrase

			recall: a private key is 256-bits (2^256) <<< 512-bits (2^512)

		Creating a HD wallet from the seed

			the seed is hashed to a 512-bit string
				left 256 bits are the master private key: m
				right 256 bits are the master chain code: c

			chain code is used to introduce entropy when creating child keys from the parent keys

			each child key is created with
				the parent private/public key (256 bits)
					if private, private child key is create, public otherwise
				the parent chain code (256 bits)
				an index number of 32 bits: 0, 1, ... 2^32

				all 3 are mixed and hashed to create children keys
				the index allows to create 2 x 2^31 children keys
					half are normal derivation keys
					the other half hardened keys -- see below

			we cannot get the parent key from a child key, and any child key is a fully functional stand alone normal key

		Extended keys = private/public key + chain code
			public: they sart with xpub...
			private: xpriv...
			they can create alone all possible children keys

			IMPORTANT: we can create public child keys without private parent keys, just with the public parent keys!
				However, be careful, because our whole tx history becomes public
				Very interesting applications derived from that:
					1. we can upload our xpub to a web/ecommerce application and use it without our priv keys online!
					2. we can have an offline paper wallet and generate our public keys for it without putting the wallet online!

			IMPORTANT NOTE: harware wallets never export private keys, unless we explicitly do it

		Hardened child keys
			In order to break the connection, the parent private key is used to derive the child public key
			This way, we can have an xpub branch that is not connected to any other -> that means more security and privacy
			Therefore, hardened key derivation creates a gap

			with the 32 bit index, we create 2^32 children keys: 2 x 2^31
				0 to 2^31-1: normal derivation children keys
				2^31 to 2^32 - 1: hardened children keys

		HD wallet identifier paths: keys are denoted with a path

			M/x/y/z: public keys derived from master public key
			m/x/y/z: private keys derived from master private key

			m/0
				first child private key of the master private key
			m/0/1
				second child of the first child
			m/0'/0
				m/0': hardened child

			the tree can be as deep as we want and in each step, we can create 4 billion children: 2 normal, 2 hardened

			BIP-44 proposed using a convention

				m / purpose' / coin_type' / account' / change / address_index

				m / 44': means it follows the BIP-44 convention
				m / 44' / 0' : Bitcoin
				m / 44' / 1' : Bitcoin testnet
				m / 44' / 2' : Litecoin

				we can have several accounts in the wallet related to bitcoin
				for each account, we can have change adresses that the the change of the tx

## Chapter 6: Transactions

	Transactions are public entries in the blockchain in which value transfers between participants are encoded
	Although explorers and other interfaces show many fields for a tx (eg, adresses), these are high level constructions that are not really in a tx

	A transaction encoded in the blockchain has basically these fields
		vin: Inputs (where the value goes to)
			tx id: reference to the transaction that contains the UTXO that is being spent
				and the index vout of the UTXO in that transaction
				we need to go to the tx referenced and check the UTXO in order to see the value being spent!
			scriptSig: unlocking script that gives access to the funds to be spent
				it CONTAINS the address (public key hash) of the receiver
			sequence: 
		vout: Outputs (where the value comes from)
			values: amounts in satoshis (plural, in case we have several)
			scriptPubKeys: locking script that locks the funds to be spent
				it USES the signature and the public key of the wallet from which we'd like to spend

		IMPORTANT
		-> the unlocking + locking script are executed in sequence; if successful (ie, wallet proves it is owner of priv-pub key assigned to funds), tx is integrated into blockchain
		-> every node needs to confirm the transaction

	UTXO = Unspent Transaction Output = vout (VERY IMPORTANT)
		Indivisible chunks of bitcoin recorded in the blockchain that are waiting to be spent
			Outputs are INDIVISIBLE and INTEGERS = measured in satoshis
			INDIVISIBLE means: an UTXO can be consumed only in its entirety; for that, if amount sent doesn't match, we need to either
				gather several UTXOs
				generate change
				-> wallets automatically take care of that; if we're programming, we need to code that!
		Bitcoin nodes track them, there is a UTXO set
		When a transaction is executed, funds from the UTXO set are transferred and the set is changed
		Wallets select UTXOs they control to form the transaction

	Transactions have implicit FEES = sum(Inputs) - sum(Outputs)
		Fees are not explicitly in the I/O values, but these are derived from substraction: sum(Inputs) - sum(Outputs)
		Exception: Coinbase Transaction
			This is the first entry in each blockchain block
			Here, no UTXO inputs are consumed, but the winning miner node is rewarded with new generated satoshis
			This input is called coinbase
		We need to go to the referenced inputs (spent UTXOs) to compute the fees
		Wallets usually compute fees automatically
			a value of satoshis/byte is chosen, and then the final value depends on the size of the tx (not the value sent)
			fees are not mandatory, but txs with higher fees are prioritized, because miner nodes select them from the mempool, since they can get the fees
			to check current fees of unconfirmed txs
				https://bitcoinfees.earn.com
				curl https://bitcoinfees.21.co/api/v1/fees/recommended

		Fees have 2 functions
			1. compensate bitcoin miners for securing the network
			2. it becomes economically infeasable to flood the network with useless transactions


	Transactions are serialized into a byte-stream to transmit them
	Wallets select UTXOs they control to form the transaction


	Transaction Scripts and Script Language
		transaction script language is called "Script"
		properties
			- very simple
			- Turing-incomplete language: no loops (to avoid infinite loops)
			- all information necessary in the scripts

		we have an unlocking script part (of the used UTXOs) and a locking script part (which assigns the funds to an address)
		KEY IDEA: both parts are executed sequentially - if the result is true, teh tx is successful
			therefore, we have some kind of programmable money for which we can script infinite variations and sets of conditions that need to yield true
			these are SMART CONTRACTs: tx happens if script conditions are met, whatever these conditions are

		Scripts: How the language works

			Operations and variables are sequentially stacked into a stack in LIFO order: one on top of the other
			Typical operations are:
				ADD: last (top) two popped from stack, sum added to stack,
				DUP: duplicate last (top) stack element and push it,
				EQUAL: pop last (top) two and push TRUE if both are equal, else FALSE
				...

		P2PKH: the most common script: Pay-to-Public-Key-Hash = spend funds to pay to an address (= Public Key Hash)

			scriptSig (unlocking) 			scriptPubKey (locking)
			we provide proof to spend 		our wallet has the funds to be spent
			--------------------------		-------------------------------------------
			<sig> <PubK>				+ 	DUP HASH160 <PubKHash> EQUALVERIFY CHECKSIG
			--------------------------		-------------------------------------------

			<sig>: signature of the wallet that wants to spend added to stack
				The signature is created with the message (transaction) and the private key
				It can be checked it was created by the PrivK by using the PubK
				That is the main idea!
			<PubK>: public key of the wallet that wants to spend added to stack
			
			DUP: push top element <PubK> to the stack
				now, stack is:
					<PubK>
					<PubK>
					<sig>
			HASH160: it hashes the top element in the stack and pushes it: hash(PubK) = PubKHash = Address
			<PubKHash>: PubKHash = Address pushed to the stack
				now, stack is:
					<PubKHash>
					<PubKHash>
					<PubK>
					<sig>
			EQUALVERIFY: 2 top items of stack popped and checked if equal; execution continues is true
				basically, we check that the wallet that wants to spend is providing the PubK that matches with the address that has the UTXO funds
				if equal, stack is:
					<PubK>
					<sig>
			CHEKCSIG: finally, <PubK> and <sig> are popped and the signature verification algorithm checks that <sig> is valid for <PubK>
				If true, tx is valid
				The signature is created with the message (transaction) and the private key
				It can be checked it was created by the PrivK by using the PubK
				That is the main idea!

		Digital Signatures

			Look at my hand-made drawing on p. 148 (or google digital signature verification)

			Main idea: in asymmetric cryptography the other person encrypts a message for us with OUR public key (PubK) and we decrypt it with our PrivK.
			BUT NOW: we use the PrivK and PubK the other way around:

				We take the message (in Bitcoin, the transaction) and produce a unique digital signature
				with it and the PrivKey
					
					signature <- cryptography(message + PrivK)

				We send to the network nodes (or to the other party)
					the signature
					our PubK
					and the message = the transaction

				Any node can verify with our PubK and the message
				that the signature was created with the PrivK pair

			Therefore, we sign with our PrivK + Message, the others verify with out PubK + Message

			As a consequence, digital signatures
				1. authenticate the sender or owner of funds (authentication)
				2. proof that the sender cannot deny having sent the message/transaction (nonrepudiation)
				3. proof that the message has not been altered (integrity)

			In the book, more details on the process of signature generation and co. are given, not depeened here

				- signatures have two parts: R & S, used for different steps...
				- SIGHASH types: flag of the signature which tells which part of the transaction is signed
					I don't understand exactly how, but that makes possible
					crowdfunding transactions
					blank-check transactions
					dust collector transactions: we collect change amounts smaller than the fees
				- a random number is used in the process of signature generation, and it must be really random!

	Final notes: P2PKH vs 'Strage Transactions'

		Most common txs (80%?) are P2PKH = pay to an address (PubK hash)
		The rest are called 'strange transactions'; they are not strage, they simply have another type of locking/unlocking script.
		Sometimes, blockchain explorers mark them in red as strage and make the warning that they cannot decode them - it's really nothing wrong with them, they simply are not P2PKH

## Chapter 7: Advanced Transactions and Scripting
	
	Multisignature scripts
		N PubK are recorded and at least M of those must provide signatures to unlock the funds
		due to a bug, these scripts start with 0

	Pay-to-Script-Hash (P2SH)
		Multisig transactions make the scripts (thus, also transactions) longer and more complex
			Recall the fee is proportional to the size of the transaction
		Workaround: we pay to a redeem script hash and this script needs to unlock the funds later
			Effect: the burden of the fees and the complexity of the script is shifted to the recipient (spender) of the transaction
		Basically, the script is hashed to create an adress and we send bitcoins to that address
		This is commonly used with multisignature transactions
		P2SH addresses start with 3

	Data recording outputs
		It is possible to record data in the blockchain, eg, a digital fingerprint of a file as proof-of-existence on a date
		These transactions do not involve spending bitcoins
		People argued that they cause blockchain bloat: they create UTXO that cannot be spent
			BUT: the RETURN operator was introduced for that, among others: these kind of txs don't land in the UTXO memory pool
				basically, if OP_RETURN comes up in the script, 0 bitcoin UTXO is generated and we get FALSE and halt

	Timelocks = restructions on transactions or outputs that only allow spending after a point in time
		two types, or implemented at two levels
			1. through tx field nLocktime
			2. with operator CHECKLOCKTIMEVERIFY

		1. nLocktime
			cutom field in the transaction: nLocktime
			if 0, immediate propagation
			if < 500 million, it is interpreted as block height
			if > 500 million, Unix Epoch time = seconds since Jan-1-1970

			Problem: if used, double-spending is possible! Example:
				Alice sends a tx to Bob with nLocktime = now + 3 months (so to be spendable in 3 months)
				Bob gets the tx, but he can't use it: he can spends the bitcoins in it after 3 months
				BUT: Alice can create anothe tx that spends those bitcoins!!

		2. CHECKLOCKTIMEVERIFY
			This happens with an operator, introduced in December 2015 (BIP-65).
			This solves the double spending issue.
			The operator takes as parameter the time value in the same format as nLocktime

		Relative timelocks: CHECKSEQUENCEVERIFY & nSequence
			The tx is done and the UTXO is confirmed in the blockchain
				A relative timelock specifies an elapsed time from the confirmation as condition for speding the UTXO
				The clock doesnt't start ticking until the UTXO is recorded in the blockchain
			They allow a chain of 2+ iterdependent txs to be held off chain
			THAT IS ESSENTIAL FOR TECHNOLOGIES SUCH AS THE LIGHTNING LAYER!
				These are essentially bidirectional state channels

			Like normal timelocks, relative timelocks are implemented at two levels
				1. transaction level: field nSequence
					note: oroginally nSequence was intended to allow modification of txs in the mempool, but never used like that
				2. script operator level: operator CHECKSEQUENCEVERIFY

		About Time Synchronization
			Bitcoin is a decentralized network: each participant has its own perspective of time...
			Eventually, everything is synced every 10 minutes (new block)
			There are possible malicious actions that could be exploited in this respect
				To avoid them there are some consensus rules, like
					Median-Time-Past: median of the last 11 blocks (so time is aprox. 1h behind)
				But I don't fully understand the problem and the solution here...

	Scripts with flow control: IF .. ELSE .. ENDIF
		We can have unlimited nested conditions - but consensus rules impose a limit in the size of the script
		We can build redeem scripts that, for example, have two signers and either one is able to redeem

## Chapter 8: The Bitcoin Network

	Bitcoin is structured as a peer-tp-peer (P2P) network on top of the internet
		all peers are equal, there are no special nodes
		there is no hierarchy, we have a flat topology
		other P2P examples
			Napster, BitTorrent

	In addition to the P2P protocol, there are some other protocols that coexist within Bitcoin and extend the "main" P2P network
		Stratum: minining pools use it
		lightweight wallet protocols
		other mining pool protocols
		...
		they all together form the so called extended bitcoin network

	Although all nodes have the same power, they can have several modules (with functionalities) or not

		Modules / Functionalities
			Wallet: keys stored and the ability to sign & spend
			Mining: new blocks are written to the blockchain and new bitcoins rewarded
			(Full) Blockchain: full history of transactions
			Network Routing: txs and any other information are propagated to connected peers

		Full nodes
			have the full blockchain and can autonomously verify any tx without external reference
			they usually are wallets that can verify by themselves
		Mining nodes
			don't need to have the full blockchain
			they compete to create new blocks to solve the Proof-of-Work algorithm
			they usually run on specific hardware and often are grouped in pools
		SPV nodes = Simplified Payment Verification, aka lightweight nodes
			they don't have the full blockchain, but a subset (headers)
			they request information with privacy techniques in order to complete the view of the blockchain they need
			they are usually mobile lightweight wallets
		Edge routers
			they basically are full nodes without wallet
			they can verify and propagate txs
			usecase: explorers, exchanges

	Bitcoin Relay Networks

		the main P2P bitcoin network has too high latency for scpecialized needs of mining nodes
		Solution: Relay networks
			these are like highways that provide fast shortcuts - but local roads are necessary to arrive to the destination
		Matt Corallo implemented some of them, eg
			FIBRE = Fast Internet Bitcoin Relay Engine
				UDP-based raly that relays blocks within a network of nodes

	Network discovery

		the first time a node boots, it uses 'DNS seeds' (ie, predefined hardcoded servers) to connect to a peer
			we can also force by hand the IP of the server we'd like to first use	
		after a handshake (initial messages with version info, etc, exchanged), a random list of peers is provided to the new node, and the node connects to them
			then, the download of the blockchain starts: the node knows only the first block, the rest is downloaded from the peers
			the number of blocks transferred is controlled to avoid collapsing the network
		in next reboots, the node has its own list of last peers and it connects to any of them to repeat the same procedure

		connections occur on port 8333 using TCP

		we can get info on our peers with

			bitcoin-cli getpeerinfo
	
	SPV Nodes = Simplified Payment Verification

		SPV nodes download only headers, not the txs in each block -> 1000x smaller
			instead of getblocks, getheaders is used
		Verification relies on peers that provide partial views of the blockchain on demand
		SPV nodes connect to random peers for that
		SPV nodes are not as secure as a full node, but still are secure enough

		IMPORTANT ISSUE: PRIVACY
			Since SPV nodes need to ask for specific txs and addresses, we might reveal our addresses!
			Solution: Bloom Filters are used
				Bloom filters are probabilistic search filters
				Basically, we search for patterns rather than concrete txs or addresses
				The degree of privacy can be tuned in the filter
			However, even with Bloom filters, targeted traffic monitoring can reveal information

	Encrypted and Authenticated Connections

		Bitcoin communications are NOT encrypted
			This is not an issue for regular full nodes, but it can be a problem for SPV nodes (although Bloom filters are used)
		Ways to increase provacy:
			1. Tor transport
				The Onion Routing network
					encryption and excapsulation of data through randomized network paths
					it offers anonimity, un traceability, privacy
				It is used automatically if connection is available (permissions to access the Tor authentication cookie)
					does myNode have it??				
			2. Peer-to-peer authetication and encryption
				the BIPs 150 & 151 defined that
				In particular, SPVs would benefit greatly
				And in general, the whole bitcoin would be more secure: resistent to control and surveillance
				not implemented yet?

	Transaction pools

		Nodes mainatin a list of unconfirmed txs: the transaction pool
			these txs are knownn to the network, but still not registered in the blockchain
		The list is dynamically generated by each node - so it differs from node to node
		This list is used to track incomming paymets to the user's wallet

		Some nodes have also a persistent (stored) database of all UTXOs: tx outputs that have not been spent

## Chapter 9: The Blockchain

	The blockchain is a sequence of blocks that contain transactions
	Each block has a header, which is metadata about the block itself
		block metadata (headers) are stored using Google's LevelDB
			https://github.com/google/leveldb
			LevelDB is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values

	Blocks are often represented as stacked one on top of the other
		hence: height = th enumber of the block

	Each block
		- has as unique identifier a block (header) hash
			IMPORTANT: this hash is only in the child block; for the current block or any block we receive, we compute it! (and it is computed every time for verification)
			IMPORTANT: the hash is computed only with the header, not the txs - but the header has a merkle root hash of the txs
		- has a parent block: the previous block
			the hash of the parent block is in the header of the block
			IMPORTANT: this cascade effect makes imposible to modify the content of the past blocks
				if we falsify on block, we need to falsify all preceeding blocks accordingly
				this is energetically imposible
		- produces several children blocks, among which only one is selected (the one of the winning miner) and added to the blockchain


	Structure of a block

		Block size (4 bytes)
		HEADER (80 bytes)
			- version
			- previous block hash: hash of th eparent block
			- merkle root hash: hashed summary of the txs
			- timestamp
			- difficulty target: Proof-of-Work algorithm difficulty target
			- nonce: a counter used for the Proof-of-Work algorithm
		Tx counter (1-9 bytes)
		TXs (around 500 txs of 250 bytes/each on average -> 1000x smaller than the header)
			list of txs included, one after the other

	Genesis Block

		This is the first block, block with height 0, defined by Satoshi Nakamoto
		It is hardcoded so that it cannot be altered
			every subsequent blocks must match with it if gone backwards
		It has a message encoded:
			The Times 03/Jan/2009 Chancellor on brink of second bailout for banks
		The message is a proof the block is at least from 03/Jan/2009s

	Merkle Trees

		merkle tree = binary hash tree
		it hashes the transactions of a block summarizing them
		it is computed by recursively double-hashing pairs of txs or hashed tx pairs, bottom-up:
			let's consider a set of 4 txs: A, B, C, D
			H_A = SHA256(SHA256(A))
			H_B = ...; H_C, H_D
			H_AB = SHA256(SHA256(concat(H_A, H_B)))
			H_CD = ...
			H_ABCD = SHA256(SHA256(concat(H_AB, H_CD))) = merkle root hash (ALWAYS 32 bytes, no matter how many txs)

		if we have an odd number of txs, last one is doubled to obtani an even number (and a balanced tree)

		to prove that a tx is included in a block, a node needs to produce log2(N) 32-byte hashes that form the merkle authentification path
			N: # txs ~ 500 txs in a block is usual
			n = log2(N): # hashes ~ 9 for 500 txs

		IMPORTANT: Merkle trees are especially important for SPV nodes - this is what they do
			- SPVs download headers
			- The node has a tx and wants to verify that it is in a block
				instead of downloading the full lock
				it requests the merkle path of the block
				with the tx, the header (which contains the merkler root hash), and the merkle path,
					we can verify that the tx is in the block
				IMPORTANT: the point is: the merkle path is way more smaller in size than the complete set of txs in a block!

	Other Bitcoin blockchains

		mainnet
			default blockchain, where the bitcoins are registered

		testnet
			parallel blockchain to test new features publicly
			the bitcoins in the testnet are meant to be worthless
				however, some people use GPUs & ASICs, which increases difficulty
				and consequently the coins end having and inherent value, since more ENERGY is necessary to produce them
				therefore, the testnet blockchain is reset every now and then: it restarts with a new genesis block

			the same commends are used, but with the switch -testnet:

				bitcoind -testnet
					~/.bitcoin/testnet3 is created and blockchain starts being downloaded there
				bitcoin-cli -tesnet getinfo
				bitcoin-cli -tesnet getblockchaininfo
				...

		segnet
			especial testnet designed to test the Segregated Witness (SegWit) feature
			since the feature was merged already, this network is not necessary anymore

		regtest
			Regression Testing network that runs locally on our computer/node
			testent is public, but this one is local

		usual pipeline when a new feature (eg, of a wallet we're developing) needs to be deployed
			1. test locally in the regtest; if it works, then
			2. connect to the testnet; if it works, then
			3. deploy it to production in the mainnet

## Chapter 10: Mining and Consensus

	Mining secures the bitcoin system and enables the emrgence of network-wide consensus without central authority
	Why?
		each node is able to add a block to the blockchain if it solves the Proof-of-Work algorithm
		if that's achieved, new bitcoins are generated and awarded to the miner node + all the fees in the txs of the block go to the miner node as well
		after solving the PoW problem, the solution (easy to check) is integrated within the block, and the block sent to all other nodes
			the block will be accepted for inclusion into the global ledger if all consensus conditions are strictly met
		it is in the interest of all miners to accept as soon as possible correct blocks because
			- they try to mine and get bitcoin under the same rules
			- the race for the next block starts after the last one has been found
		Therefore, all mining nodes are incentiviced to follow the rules and accept peer solutions that strictly comply with the rules - thus, decentralized global consensus without central authority emerges


	Bitcoin economics and currency creation

		every 210.000 blocks (~ 4 years if 1 block/10 minutes), the reward of new bitcoins halves - that's known as the halving
			1st cycle: 50 bitcoins / new block (2009.01-2012.11)
			2nd cycle: 25 (2012.11-2016.06)
			3rd: 12.5 (2016.06 - 2020.05)
			4th: 6.25 (2020.05 - 2024)
			...
			32 halvings until approx. 2137: in last cycle 1 satoshi/block
			from 2140 on, miners get only fees as rewards
				note that nowadays fees represent only ~0.5% of the total earnings when a block is mined
			in total 21 million bitcoins generated

		the finite and diminishing issuance creates a fixed monetary supply resistant to inflation

		inflation vs deflation

			in deflation, monay acquires purchasing power over time
			many economists fear that scenario,
				because people would stop spending (lower demand), and the economy would collapse
			bitcoin experts argue that deflaton is not bad per se:
				in BTC, deflation is not cause by decreased demand, but decreased SUPPLY!
				inflation causes debasement of money value, it's like a hidden taxation that punishes savers

			BUT: in reality, nobody knows if a deflationary currency is good - maybe it does outweight the drawbacks of an inflationary monetary system.

	Decentralized consensus

		in bitcoin, there is no centralized clearinghouse that audits the system and the ledger
		instead, all nodes are able to audit it and come to the same conclusion - that's emergent consensus

		Emergent consensus is not an extra mechanism, it is arises through the interplay of 4 factors:
		1. Independent verification of each transaction
		2. Independent aggregation of those transactions into new blocks, which are added to the blockchain if PoW is demonstrated
		3. Independent verification of new blocks and assembly to the blockchain
		4. Independent selection by each node of the chain with th emost cumulative computation demonstrated by PoW 

			In other words:
			1. all txs are checked
			2. txs are independetly selected to form new blocks and the solution to the PoW is checked
			3. all new blocks are checked
			4. if there are 2 simultaneous chains, the one with the largest computation proof is selected

		Each point is discussed in the following:

		1. Idependent verification of transactions

			invalid txs are not propagated to peers; some of the criteria to verify
			- matching tx in the pool ust exist
			- matching output & input values, all correctly referenced and signed
			- syntax and data structure
			- size under limits
			- output amount in range [21m, dust]
			- correct nLocktime & nSequence
			- ...

			interestingly, conditions might change over time to handle
			- other types pf txs
			- adress new denial-of-service attacks

		2. Aggregating transactions into blocks

			while mining, nodes are receiving in parallel new txs and adding them to the tx pool, if valid
			the first transaction added to a new block is the coinbase transaction:
				it generates new bitcoin instead of spending existing UTXOs
				thus, the winning miner receives
					1. the reward, which varies in function of halving cycle (2020 -> 6.25)
					2. the fees of all the included txs: fees = sum(inputs) - sum(outputs)
					all these numbers must match to be accepted as valid!
				coinbase txs has a specific structure that must be satisfied
					there's a field which can be used as desired
					Satoshi wrote in that field the famous
						"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"

			after conforming and selecting the txs of the new block, the header must bet created - which must be correct, too

			Mining the Block

				Mining is the process of hashing the block header repeatedly chaging one parameter until the resulting hash is below a specific target

					while (hash(header + nonce) < target)
						nonce++
					if we get out of the loop, we found the valid nonce value!

				key idea: the value of the target is inversely proportional to the difficulty
					if we decrease the value of the target, finding the nonce is more difficult -> more trials must be performed, more computational effort is expected
					in other words: decreasing the target means augmentzing the range of possible nonce values
						take into account that any value in the range can be correct

				note: hash < target can be understood as how many 0s the hash must have as preceeding digits
					note that the resulting hash is always 256 bits

				therefore, IMPORTANT concepts: Difficulty, Hash power
					how many hashes (of the header) per second
					bigger difficulty (thus, hashing power) means more electricity consumption
					interestingly, difficulty doesn't increase with the number of txs, but with the accumulated power of mining nodes

				The difficulty is adjusted every 2016 blocks = 2 weeks
					bitcoin is created so that we have 1 block every 10 minutes
					if more mining nodes appear and HW is improved, the total hashing power increases
					therefore, blocks woould be mined faster
						or viceversa, some nodes might decided to stop mining because it's not profitable!
					therefore, every 2 weeks retargetting is done by all nodes

						difficulty adjustement = time required for 2016 blocks / 2016*10

				???? I don't understand how the global network difficulty is fractioned to the mining nodes
					If all nodes start with the same nonce and increase linearly, the total difficulty is not fractioned, is it???

		3. Validating a new block

			Every time a miner finds the solution (nonce) that matches the PoW (hash < target)
				it packs the block and sends it to the peers
			If the block is not completely correct, it is discarded
			Some criteria
			- syntactically valid
			- hash(header + nonce) < target
			...

			Independent validation assures that the miners cannot cheat

		4. Assembling and Selecting Chains of Blocks

			If two valid blocks A & B are mined almost simultaneously, they are propagated to the whole network
			Part of the nodes will include A, part B, but eventually both A & B will arrive to all nodes
			In such cases, forks are originated in the blockchain, which are usually resolved within a block creation time (10 mins) - if not in a block, the in 2
				1-block side branches appear every day, 2-block branches every few weeks
			The resolution is done by selecting the branch with the largest demonstrated computation
				longest height
				largest accumulated PoW (nonce - hash)
			If a valid block is received without a parent, it goes to the orphan block pool
				This happens when the child arrives before the parent
				This sitiation is equally resolved when the parent arrives
			THEREFORE: Consensus is: the chain with the largest cummulative work wins

			10-minutes new block design is a compromise between
				- fast confirmation times
				- lower probabilities of forks due to propagation delays

	Mining and the Hashing Race

		Hashing power (Hash/second, H/s) increases exponentially (2x - 14500x per year), driven by
		- the number of mining nodes
		- the performnace of the HW used
			in 2009-2011 CPUs were replaced by GPUs & FPGAs
			in 2012-2014 the previous were replaced by custom ASICs

			nowadays, a limit in technology seems to have been achieved
			the factors are
				- how many nodes
				- how many chips can be packed densely and the heat still dissipated
				- price of electricity so that it's profitable

		As the hashing power increases, the difficulty increases similarly
			difficulty is measured as ratio of difficulty wrt first block

		Mining pools
			miners can join to mining pools instead of being solo
				so hashing power is shared among all ppers in the pool
				rewards are shared in proportion to the provided hashing power
			pools are open to anyone
			pools are operated/managed by pool operators

			P2Pool: decentralized maning pool operator protocol
				a centralized pool manager could manipulate the shares
				this protocol avoids that, because it implements parallel blockchain-like system

	Consensus Attacks

		Consensus attacks are theoretical - they consist in organized attacks or miners with enough hashing power
		The attacks could happen only in the blocks being mined at the moment, not in the past blocks of the blockchain
		Consensus attacks are also known as "51% attacks"
			because if a group of miners with 51% of the total hashin g power could cause them
			however, in theory, having 30% of the total hashing power, it should be possible to carry out the attacks, too

		Two major types of consensus attacks
			- double spend:
				the group of miners coordinates to spend again the amount already spent in a unconfirmed transaction
				thus, it is usually recommended to wait for 6 confirmations after we transfer a big amount
			- denial-of-service:
				specific set of addresses are blacklisted

		One possible attack scenario consists in a conporation or a state aquiring a large amount of mining nodes are causing denial-of-service attacks to addresses; this way, bitcoin could stop working

	Changing the Consensus Rules

		Consensus rules are invariable in the short-term, BUT they are NOT invariable in the long-term!
			Hard Forks: when consensus rules change
				they require coordination between all participants in the system
			Soft Forks: consensus rules change, but these are forward-compatible:
				unupgraded clients can continue in the same chain with the new rules

		Hard Forks: consensus rules change, new chains appear
			- they happen in different stages: 
				first node software must be changed (forked),
				then the network forks,
				then miners fork,
				lastly the chain forks (splits)
			- when the chain forks, we end up having a new coin and the hashing power is split
				example: Bitcoin Cash; it was contentious
				consequence: BTC coins prior to fork are still available in the new chain!

		Soft Forks: consensus rules change, but no new chain appears because new blocks/txs are valid for old nodes too (nodes with old consensus rules)
			They can be implemented by
				- changing the code of the rules
				- with NOP operations
				- with other mechanisms, such as it was done with SegWit (see chapter/appendix)

			NOP opcodes are 10 empty opcodes (NOP1 - NOP10) to be defined in time
				some have been already defined, eg:
				NOP2 = OP_CHECKLOCKTIMEVERIFY

			Criticisms of soft forks

				soft forks based on NOP codes are relatively uncontroversial, because NOPs were conceived for that
				but other type of soft forks are critiques because
				- they can cause technical debt, since they are technically more complex to achieve
					eg, bugs, security vulnerabilities, ...
				- validation is relaxed: un-upgraded nodes are not validating the full range of consensus rules
				- irreversible upgrades can cause to loose funds distributed with old rules ??

			Signaling: Method to allow miners to signal which consensus set they support

				basically, when a change is proposed and implemented, miners need to signal if they agree or not
				when incorporating a new version (eg, from consensus set n to n+1), the following signaling is expected
				- if 750/1000 last blocks contain the signal for n+1, n+1 is default, but n is still compatible 
				- if 950/1000 last blocks contain the signal for n+1, n+1 is default, n is NOT compatible anymore

				the field block version is used for that
				in the beginning, the integer value was used
					version = 1, 2, ...
					each number indicated support for a new BIP
				later, the version field started to be interpreted as a bit field (BIP-9)
					- several (29) changes can be signaled siultaneously
					- start and end time for signaling is specified

			??? Questions
				- Which is the organization/structure behind?
				- Who are proposing BIPs?
				- Who are choosing which BIPs to implement?
				- Who is financing them?
				- Who is controlling the github account?
				- How are changes/intentions communicated?
				- Is there a roadmap?
				-> address these questions when the chapter/appendix about BIPs is analyzed

## Chapter 11: Bitcoin Security

	Security Principles: Centralized vs Decentralized Systems

		centralized models must control access to vet bad actors
			bitcoin pushes responsibility and control to the user, the system itself is secured through Proof-of-Work

		centralized systems need to encrypt their comms,
		eg, to avoid leaking credit card numbers of transactions that can be used to steal money
			bitcoin doesn't need to encrypt comms, no private information is leaked in txs, and tx info cannot be used to steal
			thus, we could execute txs on usecured wifi areas
			BUT: users are responsible of making good storage of their keys
		
	Root of Trust

		Tradictional security architecture is built in layers
		The core layer is the root, the most simple part, and the one in which we most trust
		Outer layers add complexity and we trust them less

		Bitcoin is different: the only thing that should be explicitly trusted is a fully validated blockchain!

	Best Practices

		- Do not take funds off-chain unless necessary: the blockchain itself secures your funds; any off-chain system is less secure
		- Physical bitcoin storage can be used: eg, paper wallets
			multiple copies, stored in safes
			cold storage = offline
		- Hardware wallets should be used, eg Trezor or Ledger or Coldcard
		- Balance risk: files can get lost! Make sure your files (digital or physical) won't
		- Diversify risk: it is risky storing all the bitcoin in a single wallet!


## Chapter 12: Blockchain Applications

	VERY IMPORTANT CONCEPT:	
	Bitcoin is built using simple concepts upon which more complex elemets and applications can be built
		for example, we have just txs and the blockchain
		there are no explicit accounts, users, balances, etc.
		Similarly, we can use the blockchain as an application platform offering trust services to applications,
			such as smart contracts

	Building Blocks = Primitives: Basic elements of Bitcoin upon which applications can be built
		- No double spend: no UTXO can be spent 2x
		- Immutablity: txs become immutable
		- Neutrality: valid txs propagated regardless of origin/content
		- Secure timestamping achieved
		- Authorization guaranteed with digital signatures
		- Auditability: all txs public
		- Accounting is inherent: Inputs = Outputs + Fees
		- Transactions don't expire
		- Transactions are atomic: they are either valid and confirmed or not
		- Discrete and indivisible units of value: tx outputs cannot be divided, they can be unspent or spent in full
		- Quorum of control: multisignature scripts are possible with M-of-N requirements
		- Timelocked txa are possible
		- Transactions are propagated and replicated in the network
		- Forgery protection: a transaction, to be valid, needs to have validated outputs
		- Consistency: blocks, once recorded, need an unfeasible amount of energy to be modified
		- A transaction can commit external data value with OP_RETURN
		- Predictable issuance: 21 million bitcoins

	Applications from Building Blocks

		- Proof-of-existence (digital notary): digital fingerprints that prove document existence with timestamp
		- Kickstarter fundraising
		- Payment channels (see section below)

	Colored Coins

		An amount of bitcoin, eg a satoshi, is marked to represent something other than the bitcoin value itself
			for instance: a stock certificate, a gol redeemable certificate, etc.
		Colored coins use the OP_RETURN script code and the information of the representazion is stored in the tx metadata in conjunction with other external data stores that associate the metadata with specific assets

		Therefore,
			colored coins must be created, transferred, stored and explored
			with specific clients, wallets, explorers

			they are often not visible to normal explorers and if used with regular wallets, the metadata might be lost

	Counterparty

		Protocol layer built on top of bitcoin which offers capabilities similar to colored coins:
			create and trade virtual assets and tokens
		They are also implementing smart contracts based on Ethereum

	Payment Channels and State Channels

		Trustless mechanism for bitcoin transactions outside of the bitcoin blockchain: off-chain
			promisory notes are transacted for eventual batch settlement in the blockchain

			they allow:
				high tx throughput
				low latency (sub-millisecond)
				fine granularity (sostoshi)

		The word channel is a metaphor - as in TCP we have no channel

		A state channel
			is stablished by 2 parties with a funding transaction (initail balance)

			then, signed transactions or commitment txs are executed, which alter the initial state

			the last state is the ones that is settled in the settlement tx;
			it happens after the last up-to-date commitment transaction

			thus, the bitcoin blockchain only sees 2 txs (funding, ssettlement), although many could have happened in between (commitment)

		The funding tx sets the channel capacity: maximum amount that can be transmited

		Note that all commitment txs are timelocked
			That is an essential feature to make them work.. I didn't go deep enough to understand why and how

		Commitment txs can be revoked

		Hash Time Lock Contracts (HTLC)

			These are a basic tool for the Lightning network

			Basically, the participants commit funds to a redeemable secret with an expiration time

				anyone who knows the secret that produces the hash can redeem the funds
				if that doesn't happen, after a given number of blocks the payee gets the funds

	Routed Payment Channels = Lightning Network

		It's a bidirectional payment channels system, which has a very important feature:
			any participant can route a payment from channel to channel without trusting any of the intermediaries
			that means, the participants don't need to have an open channel between them, but just be connected to nodes that form a route of channels that connects them

			with Lightning, Bitcoin can scale world-wide to become a payment network
				there's no upper bound in the number of tx/second that can be achieved

		Joseph Poon and Thadeus Dryja proposed it in February 2015

		It is being implemented by at least 3 parties independently and they are coordinating a standard:
			Basics of Lightning Technology = BOLT

		Lightning uses Segwit

		How it works (p. 298)

			Imagine a route which goes from user A -> B -> C -> D
				channels are marked with ->
				users A & D are not connected, but
					A wants to pay 1 bitcoin to D

			D (receiver/payee) creates a secret R, which is hashed to H
				D gives H to A
			A's node creates a route to D
				A -> B -> C -> D
				the route is encrypted so that
					A sees all nodes
					the rest of the nodes see only who are the adjacent nodes in the route
					this is achieved with the onion-routed protocol:
						the message (which contains the path) is encrypted in layers with the public keys of the path nodes backwards so that each node knows the next recipient of the message
			A creates an HTLC transaction of 1.02 bitcoin to B
				1 bitcoin + 0.02 routing fees
				the fees are derived from the route nodes: 0.01 (B) + 0.01 (C)
				the transaction is constructed with HTLC, and it reads
					"A is commiting to pay 1.02 bitcoin to B, if B knows the secret taht yields the hash H, or refunded to A after X blocks"
				the tx contains also the encrypted path (with the onion protocol)

			B gets the tx from A, and can now unpack/decrypt the message
				B now constructs an equivalent tx to C
				C is in the message
				the amount is 1 bitcoin + 0.01 (C fee)
				it's a HTLC tx, which reads
					"B is commiting to pay 1.01 bitcoin to C, if C knows the secret taht yields the hash H, or refunded to B after X-1 blocks"

			Finally, C receives the tx and generates a tx of 1 bitcoin to D with in HTLC style
				Since D does know the secret that produces H (A sent him!)
				He sends it to to C to redeem that 1 bitcoin
				Then, C sends it to B to claim the 1.01-1 = 0.01 bitcoin in fees
				B to A -> 1.02-1.01 = 0.01 bitcoin in fees

		VERY IMPORTANT NOTE

			I see that, interestingy, in Lightning we need to allocate funds that we already have to the network
				either to pay in a channel
				or to route payments
			Therefore, we're already showing proof of payments fo subscriptions that we might not end up paying at the end!

			So it's another philosophy: we need to have funds to buy something...

## Appendix A: The Bitcoin Whitepaper by Satoshi Nakamoto
	
	Many things are missing in the paper, it's a very abstract overview of the system.

## Appendix C: Bitcoin Improvement Proposals

	How does the process work?
		Amir Taaki proposed the process
		First, the BIP is drafted according to a template and discussed in the bitcoin mailing list
			bitcoin-dev@lists.linuxfoundation.org
		Then, there is a public discussion and feeback is collected + draft modified
		The BIP editor aproves/rejects proposals depending on effort, technical soundness, etc

		The current BIP editor is Luke Dashjr
			luke_bipeditor@dashjr.org

		In Luke's LinkedIn, he says
			Available for contract work
			Seeking sponsorship for my public Bitcoin development work

		So it seems it is like a self-organized community of developers who are publicly funded and who gathered around the project along the time

	Who funds the developers?
		Some developers
			Pieter Wuille, Wladimir van der Laan, Marco Falke, Matt Corallo, ... Jorge Timon (Cáceres)
			Jorge Timon is Co-Founder of Blockstream! (he also was an engineer there)
		Some funders (they often fund concrete developers)
			Blockstream, Square Crypto, MIT, BitMEX, Chaincode, Bitmain, ...

	Which improvements were implemented?
	Which improvements are coming?

## Appendix D: Segregated Witness


####################################
# Bitcoin Udemy Course
####################################

Appendix
	
	Can bitcoin addresses collide?
		They can, but the probability os extremely low
			1 / (2^160)
			because we have 160 bits of entropy

	Segwit / Segwit2x (soft-fork)

		It was a change proposed by the community
		And miners could choose to adhere to it
		Proposed changes:
		1st phase
		- Witness data was not hashed
		- 2x more transactions per block were allowed
		2nd phase
		- the block size was increased from 1 MB to 2 MB

		the first phase was executed but the 2nd not, because miners were not interested in increasing the blocksize to 2MB
			the reason is they had already specific hardware they needed to change, and that's expensive

	Bitcoin Cash

		That was a hard fork; it implemented
		- 8MB blocks
		- 24 txs/sec vs 3 tx/sec
		- lower fees
		- BCH vs BTC

		everybody who had bitcoin before, had BCH now



####################################
# Ethereum
####################################

These notes were done after watching the Udemy course
Bitcoin and Cryptocurrency Bootcamp
by Colt Steele, Kevin Katz

Overview

	Ethereum is a decentralized payment network
	Ethereum allows users to write code that runs on the blockchain
		that means: Ethereum is not only for payments, it's also for running applications on the blockchain!

	Units, some interesting numbers
		1 Ether = 10^18 wei
			often see Gwei = Gigawei = 10^6 weis
		Maximum issuance ?
		a new block every 15 seconds!
			faster
			but less secure because blockchain splits more frequenctly

	History

		Vitalik Buterin wanted to add scripting to bitcoin
			he wanted to introduce an application layer to the blockchain
		Since he couldn't create any traction, he created a new cryptocurrency
			that was early 2014

	The Ethereum Computer

		PCs, smartphones, etc, they have CPUs
		Then, we have cloud computing
			there is a server that offeres scalable compute services
			however, one owner has these servers
		Ethereum takes the concept of cloud computing and extends it to the ethereum network
			miners do not only propagate txs, they also run the applications we write and deploy on the blockchain

			all miners run the exact same piece of code!
		
			of course, it doesn't make sense to have any application run on 1000s of computers

			Solidity is the name of the language

	Ethereum transactions transmit not only ether, but also data

Smart Contracts
	
	Contract = voluntary agreement by 2 or more parties that is enforceable by law

	Smart contract = a contract enforced by computers
		Example: a vending machine: the contract is that if we insert the right coins and select the right product, we get it - there's no 3rd party involved!

	Application on ethereum are in theory resistant to
		downtime, censorship, frauc, interference

	Example: a Deed of ownership (eg, of a house)
		we can have the paper which shows ownership in the bank
			or we could have it in the Ethereum blockchain
		we basically have the document timestamped with our adress in the blockchain

		if we sell the property, we perform a transaction in the ethereum network in which the ownership address of the document/deed is transferred

		the deed / smart contract and the transactions are stored on all the nodes of the network!

		Therefore, we can not only send coins in the transactions, but also data, information!

	Example: Election Contract

		We want to conduct a fair non-corrupt election
			and avoid trusting Government, 3rd Parties (companies which creating voting machines, etc)

		We send an address to all participants
		They are going to vote YES/NO
		The election is hosted in all machines of the network
		Basically, users send a vote instead of ETH, and these data is hashed to the blocks

		BUT: Can that actually scale to millions of votes happening in realtime on every node? And the Blockchain must become enormous!! ...

Ethereum vs Bitcoin

	Bitcoin limitations
		- transaction times (but there are supposed top layers...)
		- transaction fees
		- centralized mining
		- limited scope (it's not really a con)

	Ethereum comparison
		- 15 secons/block <-> faster confirmation
			therefore, the blockchain splits more frequently
				which makes the blockchain more prone to 51% attacks
			we need a larger bandwidth as with bitcoin
		- more predictable payout for miners
			in Ethereum not only the winner miner gets all the reward
			that's the Uncle reward
			since the blocks are more often, the rewards are also smaller
		- 5 ETH per block
		- when bitcoin network gets congested, the avg fees have spiked to 50 USD, whereas ETH fees are 1 order of magnitude smaller and more stable
		- with the advent of mining pools using ASICs (custom made chips, which are obviuosly cheaper if bought in large quantities), bitcoin mining has become centralized
			Ethereum mining algorithm is chosen to be difficult to port to ASICs, and the need to be executed in GPUs
		- Ethereum addresses can be hold by applications (and bitcoin adresses can be also hold by scripts...)
		- Bitcoin currency is a commodity; Ether is a commodity and additionally fuel for the applications

Ethereum Transactions
	
	- We can put data / scripts in Ethereum in addition to ETH
	- The transactions can be addressed to
		- accounts / addresses
		- to contracts
			?? But in Bitcoin too, we can send to scripts
			actually, the address abstraction (PubKeyHash) is used for that, among other things...

DApp = Distributed Applications

	Applications in the Ethereum Blockchain are called contracts

	Applications/Contracts are written in Solidity

	Example: a simple script is shown in which a contract Accumulate{} is defined
		- we declare a variable storeData = 0 in it
		- a function add(x) is implemented which adds x to storedData
		- anyone can call add(x)
		- storeData is in all nodes of the network, and all nodes of the network can execute add()

		- each contract gets an address starting with 0x05...
		- also each account/user/wallet has an address, starting with 0x08...

		- So, basically, accounts or scripts send to the address of our script a transaction which has the line of code add(x), which executes the add() function
			. all the computers of the network see that and execute add()!

		- We can have a front-end website which is displaying the value of stotedData

Erhereum Blockchain explored with etherscan.io

	The equivalent bitcoin adresses in ethereum are called externally owned accounts; additionally, we have contracts in Ethereum

	in etherscan.io
	transactions to a contract have an icon
		
		if we click in one of them, we can see the contract code!

		we can also see all the transactions sent to the contract!

			some of them have ETH involved
			and also, in the input data
				function calls

	Famous application: CryptoKitties
		https://www.cryptokitties.co

Ethereum Virtual Machine = EVM

	Ethereum nodes run on a virtual machine, not directly on our OS

	Ethereum is sandboxed in a virtual machine due to security reasons: we want to prevent interactions with any potentially malitious data from the host; also we want to prevent leaking data from the host to the ethereum network

	the EVM can communicate with the ethereum network only, not with the host or the general internet

	the EVM cannot access peripherals either, only basic functions of the CPU

Gas

	Image we have a contract function that enters in an edndless loop - the etehreum network/blockchain would be blocked

	The solution is Gas = the internal pricing for running a transaction on the EVM

		it limits transaction compute expense

	Every operation has a gas cost

		add 2 numbers: 3
		multiply 2 numbers: 5
		get a balance of an account: 400
		allocate/store 1 words of storage: 20.000!
			it is really expensive to store data!
			this prevents storing too much data

		Gas units are priced in ETH and prices fluctuate depending on the network congestion and ETH price

	Amount of Gas used is really defined by the sender in a similar dynamic as with bitcoin fees

		the transactions with more gas are more likely to be mined faster

	Since we often times don't know how much gas our transaction needs, we define a gas limit

		the gas limit is the upper bound we are willing to spend

		if the miner requires more gas to execute the transction:

			the transaction is rejected
			BUT THE MINER KEEPS THE GAS!

		if less gas is used, the difference is refunded to the user

Ethereum Tokens

	tokens = digital currencies implemented on top of ethereum

		instead of writing our own coin, we use the smart contract framework of ethereum to define a token

		a token is like a ticket or a voucher

		example: golem

			the idea is to publicly offer computational resources for complex tasks, eg 3D rendering, etc

			the users would arrange the exchange in golem tokens

	ERC-20 defined a list of rules or standards that tokens can/should adhere to; the standard assures minimum quality, I understand. Most of the ICO tokens follow the ERC20 standard.

		ERC = Ethereum Request for Comment
		equivalent to the BIPs

		ERC20 is basically an interface the tokens must follow

			totalSupply()
			balanceOf(owner)
			transfer(to, value)

		If a token follows ERC20, it can be listed and handled on a  Ethereum wallet

		ERC20 is not really enforced, tokens can adhere to it

	ERC721: another standard for tokens that represent unique collectibles, eg, Cryptokitties.

The DAO
	
	Hack of a smart contract on Ethereum

	DAO = Decentralized Autonomous Organization

		it was a kind of kinckstarter organization or a VC where people could propose their token ideas

		then, a voting would take place

		there was a pool of money to use: 11,500,000 ETH
			with 20 USD / ETH at the time
			220 million USD approx at the time of the hack

	there was a bug in the DAO contract in a function called split()

		someone discovered it and used it successfully to send 3,6 million ETH to other accounts/owners/addresses

		this happened in real time transparently and users could see it!!

	A decission was taken:

		they froze the malicious account(s) and returned funds back to the funders of the DAO

		this was very controversial

		a soft-fork happened: Ethereum Classic vs Ethereum

			miners that didn't agree with the patch (minority) joined the Ethereum Classic blockchain

	The point is: there was no problem with Ethereum itself, but the msart contract of the DAO had a bug that was exploited; the problem is that the DAO was a large association, too big to ignore

		The question is: where do you draw the line? Is it really decentralized functioning freezing an address?

Ethereum 2.0

	New version, deployed in phases starting Dec 2020
	Several blockchains that are subordinated to a higher level one

	Power of Stake instead of Power of Work
		Miner nodes chosen to write the block depending on
			randomness
			stake = age, amount of ETH they have
